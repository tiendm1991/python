import collections


class Solution:
    def minMalwareSpread(self, graph, initial) -> int:
        n = len(graph)
        p = [i for i in range(n)]

        def find(u):
            if u != p[u]:
                p[u] = find(p[u])
            return p[u]

        def union(u, v):
            ru, rv = find(u), find(v)
            if ru < rv:
                p[rv] = ru
            else:
                p[ru] = rv

        for i in range(n):
            for j in range(n):
                if i != j and graph[i][j] == 1:
                    union(i, j)

        d = {}
        for u in initial:
            ru = find(u)
            if ru not in d:
                d[ru] = [u]
            else:
                d[ru].append(u)
        count = collections.Counter(p)
        candidate = {d[v][0] for v in d if len(d[v]) == 1}
        if len(candidate) == 0:
            return min(initial)
        res = []
        for v in candidate:
            if not res or count[p[v]] > count[p[res[0]]]:
                res = [v]
            elif count[p[v]] == count[p[res[0]]]:
                res.append(v)

        return min(res)


s = Solution()
print(s.minMalwareSpread([[1, 0, 0, 0],
                          [0, 1, 0, 0],
                          [0, 0, 1, 1],
                          [0, 0, 1, 1]], [3, 1]))
print(s.minMalwareSpread([[1, 1, 1],
                          [1, 1, 1],
                          [1, 1, 1]], [1, 2]))
print(s.minMalwareSpread([[1, 1, 0],
                          [1, 1, 0],
                          [0, 0, 1]], [1, 2]))
print(s.minMalwareSpread([[1, 1, 0],
                          [1, 1, 0],
                          [0, 0, 1]], [0, 1, 2]))
print(s.minMalwareSpread([[1, 1, 0],
                          [1, 1, 0],
                          [0, 0, 1]], [0, 1]))
